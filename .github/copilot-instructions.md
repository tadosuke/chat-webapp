# プロジェクト概要

このプロジェクトは、Vite + React + TypeScript を使用した Web アプリケーションです。

# 技術スタック

- **フロントエンド**: React 19.1.0
- **ビルドツール**: Vite 7.0.4
- **言語**: TypeScript 5.8.3
- **リンター**: ESLint 9.30.1
- **サーバー**: Express 5.1.0

# コーディング規約

## 全般

- JSDoc、コメント、テストケースの説明は全て日本語で記述
- **Copilot の応答は必ず日本語で行う**
- `copilot-instructions.md`, `README.md` 内の説明に関連する処理を修正した場合は、これらのファイルにも反映すること

## TypeScript

- 厳密な TypeScript モードを使用（strict: true）
- `noUnusedLocals`、`noUnusedParameters`を有効化
- 型定義は明示的に記述し、`any`型の使用を避ける
- ES2022 の機能を使用可能

## React

- 関数コンポーネントを使用
- Hooks を適切に使用
- JSX は`react-jsx`変換を使用
- コンポーネント名は PascalCase で命名

### コンポーネント設計原則

- **単一責任の原則**: 1 つのコンポーネントは 1 つの責任のみを持つ
- **小さなコンポーネント**: 実装初期からコンポーネントを細かく分割する
- **100 行以下**: 1 つのコンポーネントファイルは 100 行以下を目安とする
- **早期分割**: 肥大化してからリファクタリングするのではなく、実装段階から適切に分割
- **再利用性**: 他の場所でも使用可能なように独立性を保つ

### コンポーネント分割の判断基準

以下の条件に該当する場合は、コンポーネントを分割することを検討する：

1. **複数の責任を持っている**（UI 表示とビジネスロジックの両方など）
2. **ファイルが 100 行を超えている**
3. **複雑な JSX が含まれている**（ネストが深い、条件分岐が多いなど）
4. **独立してテストできる部分がある**
5. **他のコンポーネントでも再利用できそうな部分がある**

## インポート

- 絶対パスではなく相対パスを使用
- 使用しないインポートは削除
- TypeScript ファイルの拡張子は明示的に記述可能

## ファイル構造

- `src/`ディレクトリ内にソースコードを配置
- 静的ファイルは`public/`ディレクトリに配置
- サーバーサイドコードは`server/`ディレクトリに配置
- テストコードは`__tests__/`ディレクトリに配置

### コンポーネント構造

- React コンポーネントは`src/components/`ディレクトリ内に配置
- 各コンポーネントは独立したフォルダに配置し、関連ファイルをまとめる
- コンポーネントのメインファイルは`index.tsx`として命名
- 対応する CSS ファイルは同じフォルダ内に配置
- コンポーネント構造の変更時は、全ての関連ファイル（テスト、インポートパス）を同時に更新する

### コンポーネント実装のワークフロー

新しいコンポーネントを実装する際は、以下の順序で進める：

1. **設計**: コンポーネントの責任を明確にし、必要に応じて事前に分割を計画
2. **実装**: 小さな単位で実装し、100 行を超える前に分割を検討
3. **テスト**: 各コンポーネントが独立してテストできることを確認
4. **レビュー**: 責任の分離と再利用性の観点でコードを見直し

# コミット規約

- コミットメッセージは日本語で記述
- 変更の内容を簡潔に記述
- 機能追加: `feat: 新機能の説明`
- バグ修正: `fix: バグの説明`
- リファクタリング: `refactor: リファクタリングの説明`

# パッケージ管理

- 依存関係は適切に管理し、不要なパッケージは削除
- **バージョン固定を必須とし、意図しないアップデートを防止**
- `^`（キャレット）や`~`（チルダ）などのレンジ指定は使用禁止
- package.json では必ず具体的なバージョン番号を指定（例: `"1.2.3"`）
- セキュリティアップデートなどは手動で確認・適用する
- 新規パッケージ追加時は `npm install --save-exact` または `npm install -E` を使用

# リファクタリング・構造変更ガイドライン

## 大規模な構造変更時の手順

1. **事前準備**: 現在のテスト、ビルドが正常に通ることを確認
2. **段階的変更**: 一度に大量のファイルを移動せず、段階的に実施
3. **依存関係の追跡**: ファイル移動時は関連するインポート文も同時に更新
4. **テスト更新**: 構造変更に伴うテストファイルのパス参照も更新
5. **検証**: 各段階でビルド・テストを実行し、動作確認を徹底

## 品質保証

- 構造変更後は必ず全テストを実行し、既存機能が正常動作することを確認
- ビルドエラーが発生しないことを検証
- リファクタリング時は機能追加や削除を同時に行わず、構造変更のみに専念

# インフラストラクチャ依存性管理

## 外部リソース依存性の原則

アプリケーションが外部リソース（ディレクトリ、ファイル、データベース、サービス）に依存する場合、以下の原則に従う：

1. **自動作成・初期化**: 必要なリソースが存在しない場合は自動作成する
2. **エラーハンドリング**: 作成失敗時は明確なエラーメッセージを提供
3. **冪等性**: 複数回実行しても安全な設計にする
4. **ドキュメント化**: 必要な外部リソースを明確に文書化する

## 外部API依存性の管理

外部APIを利用する際は、以下の原則に従う：

### API選択の基準

1. **信頼性**: 安定してアクセス可能なAPIを選択する
2. **レスポンス形式**: シンプルで一貫したレスポンス形式を持つAPIを優先する
3. **アクセス制限**: ファイアウォールやネットワーク制限の影響を受けにくいAPIを選択する
4. **メンテナンス状況**: 積極的にメンテナンスされているAPIを選択する

### 実装時の考慮事項

1. **フォールバック機能**: APIエラー時の適切なフォールバックメッセージを実装
2. **型定義の適合**: APIレスポンスに対応した正確な型定義を作成
3. **エラーハンドリング**: ネットワークエラー、HTTPエラーに対する適切な処理
4. **代替API準備**: 主要APIが利用できない場合の代替手段を検討

### 開発環境での制限への対処

- GitHub Actions等のCI/CD環境では、ファイアウォール制限により特定のAPIにアクセスできない場合がある
- このような場合は、より信頼性が高く制限の少ないAPIへの変更を検討する
- API変更時は、レスポンス形式の違いに応じて型定義とデータ取得処理を適切に更新する

### 実装例

```typescript
// ディレクトリ作成の実装例
import { mkdirSync } from 'fs';
import { dirname } from 'path';

constructor(dbPath?: string) {
  const defaultPath = join(__dirname, "../data/conversation.db");
  const dataDir = dirname(dbPath || defaultPath);

  try {
    mkdirSync(dataDir, { recursive: true });
  } catch (error) {
    // ディレクトリが既に存在する場合のエラーは無視
  }

  this.db = new sqlite3.Database(dbPath || defaultPath);
}
```

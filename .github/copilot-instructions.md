# プロジェクト概要

このプロジェクトは、Vite + React + TypeScript を使用した Web アプリケーションです。

# 技術スタック

- **フロントエンド**: React 19.1.0
- **ビルドツール**: Vite 7.0.4
- **言語**: TypeScript 5.8.3
- **リンター**: ESLint 9.30.1
- **サーバー**: Express 5.1.0

# コーディング規約

## 全般

- JSDoc、コメント、テストケースの説明は全て日本語で記述
- **Copilotの応答は必ず日本語で行う**

## TypeScript

- 厳密な TypeScript モードを使用（strict: true）
- `noUnusedLocals`、`noUnusedParameters`を有効化
- 型定義は明示的に記述し、`any`型の使用を避ける
- ES2022 の機能を使用可能

## React

- 関数コンポーネントを使用
- Hooks を適切に使用
- JSX は`react-jsx`変換を使用
- コンポーネント名は PascalCase で命名

### コンポーネント設計原則

- **単一責任の原則**: 1つのコンポーネントは1つの責任のみを持つ
- **小さなコンポーネント**: 実装初期からコンポーネントを細かく分割する
- **100行以下**: 1つのコンポーネントファイルは100行以下を目安とする
- **早期分割**: 肥大化してからリファクタリングするのではなく、実装段階から適切に分割
- **再利用性**: 他の場所でも使用可能なように独立性を保つ

### コンポーネント分割の判断基準

以下の条件に該当する場合は、コンポーネントを分割することを検討する：

1. **複数の責任を持っている**（UI表示とビジネスロジックの両方など）
2. **ファイルが100行を超えている**
3. **複雑なJSXが含まれている**（ネストが深い、条件分岐が多いなど）
4. **独立してテストできる部分がある**
5. **他のコンポーネントでも再利用できそうな部分がある**

## インポート

- 絶対パスではなく相対パスを使用
- 使用しないインポートは削除
- TypeScript ファイルの拡張子は明示的に記述可能

## ファイル構造

- `src/`ディレクトリ内にソースコードを配置
- 静的ファイルは`public/`ディレクトリに配置
- サーバーサイドコードは`server/`ディレクトリに配置
- テストコードは`__tests__/`ディレクトリに配置

### コンポーネント構造

- Reactコンポーネントは`src/components/`ディレクトリ内に配置
- 各コンポーネントは独立したフォルダに配置し、関連ファイルをまとめる
- コンポーネントのメインファイルは`index.tsx`として命名
- 対応するCSSファイルは同じフォルダ内に配置
- コンポーネント構造の変更時は、全ての関連ファイル（テスト、インポートパス）を同時に更新する

### コンポーネント実装のワークフロー

新しいコンポーネントを実装する際は、以下の順序で進める：

1. **設計**: コンポーネントの責任を明確にし、必要に応じて事前に分割を計画
2. **実装**: 小さな単位で実装し、100行を超える前に分割を検討
3. **テスト**: 各コンポーネントが独立してテストできることを確認
4. **レビュー**: 責任の分離と再利用性の観点でコードを見直し

# コミット規約

- コミットメッセージは日本語で記述
- 変更の内容を簡潔に記述
- 機能追加: `feat: 新機能の説明`
- バグ修正: `fix: バグの説明`
- リファクタリング: `refactor: リファクタリングの説明`

# パッケージ管理

- 依存関係は適切に管理し、不要なパッケージは削除
- **バージョン固定を必須とし、意図しないアップデートを防止**
- `^`（キャレット）や`~`（チルダ）などのレンジ指定は使用禁止
- package.json では必ず具体的なバージョン番号を指定（例: `"1.2.3"`）
- セキュリティアップデートなどは手動で確認・適用する
- 新規パッケージ追加時は `npm install --save-exact` または `npm install -E` を使用

# リファクタリング・構造変更ガイドライン

## 大規模な構造変更時の手順

1. **事前準備**: 現在のテスト、ビルドが正常に通ることを確認
2. **段階的変更**: 一度に大量のファイルを移動せず、段階的に実施
3. **依存関係の追跡**: ファイル移動時は関連するインポート文も同時に更新
4. **テスト更新**: 構造変更に伴うテストファイルのパス参照も更新
5. **検証**: 各段階でビルド・テストを実行し、動作確認を徹底

## 品質保証

- 構造変更後は必ず全テストを実行し、既存機能が正常動作することを確認
- ビルドエラーが発生しないことを検証
- リファクタリング時は機能追加や削除を同時に行わず、構造変更のみに専念

# インフラストラクチャ依存性管理

## 外部リソース依存性の原則

アプリケーションが外部リソース（ディレクトリ、ファイル、データベース、サービス）に依存する場合、以下の原則に従う：

1. **自動作成・初期化**: 必要なリソースが存在しない場合は自動作成する
2. **エラーハンドリング**: 作成失敗時は明確なエラーメッセージを提供
3. **冪等性**: 複数回実行しても安全な設計にする
4. **ドキュメント化**: 必要な外部リソースを明確に文書化する

### 実装例

```typescript
// ディレクトリ作成の実装例
import { mkdirSync } from 'fs';
import { dirname } from 'path';

constructor(dbPath?: string) {
  const defaultPath = join(__dirname, "../data/conversation.db");
  const dataDir = dirname(dbPath || defaultPath);
  
  try {
    mkdirSync(dataDir, { recursive: true });
  } catch (error) {
    // ディレクトリが既に存在する場合のエラーは無視
  }
  
  this.db = new sqlite3.Database(dbPath || defaultPath);
}
```

## 開発環境整合性

1. **README.md更新**: セットアップ手順で必要なディレクトリ・ファイルを明記
2. **初期化スクリプト**: `npm run setup` などでワンコマンドセットアップを提供
3. **開発環境検証**: 新しい環境での動作確認を必須とする
4. **統合テスト**: 実際のデプロイメント環境に近い条件でテストを実行
